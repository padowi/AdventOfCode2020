# Retrospective #

This was a fun one! Once I actually got to play with it... but I had to do a lot of adulting today, so couldn't work on it until now.
Time-wise, the file system reports that I created the input file at 21:17, and I am currently writing this retro at 21:51, last write to a.py was 21:43, and b.py was working by 21:47.

Not a fantastic time for 5a, but totally acceptable for 5b.

So, the day started with me reading the problem pretty close to when it was released to the public, and I have gone throughout the day, adulting, and mulling over potential solutions.

My first idea for a solution was the one I ended up implementing: for each boarding pass, generate a list of all the possible rows, and all the possible columns (but not a matrix, that isn't necessary), so `list(range(128))` (creating a list of integers between 0 and 127) accompanied by `list(range(8))`.

Since this was more or less a binary search problem, I would then be able to cut the list in half on each iteration through the instructions of the boarding pass data, using `mylist[0:int(len(mylist)/2)]` to get the first half of the list, or `mylist[int(len(mylist)/2):]` to get the second half of the list.

It's shit like that which makes me appreciate Python. I mean, sure, other languages are bound to have an array-slice function or something, so it isn't like Python has something unique, but Iunno, just feels very nice.

During the day I also considered whether or not it would be smarter to implement the representation of the problem as an actual tree data structure. I was fearing that 5b would throw a curve-ball and that you'd need to somehow do something tree-operation-ish that would be a pain in the ass using my "sliced list" approach.

Fortunately my colleague from day 1 retro came to the rescue by solving 5a way ahead of me, and through that did some reconnaissance for me, so while we briefly chatted mid-day he assured me that my "sliced list" approach would be sufficient for 5b as well.

I went a little overboard with associating the (row, col) or a boarding pass with the boarding pass itself, but I thought it might provide useful infrastructure for 5b.

That turned out to be an incorrect assumption, as 5b only concerned itself with finding our seat, which was an integer missing somewhere in the complete (with the exception of our one seat ID) sequence of seat IDs generated by the other boarding passes.

So, how do you find one missing number in an otherwise contiguous sequence of integers?

Say we have a list of numbers `0, 1, 2, 3 .. 125, 126, 127`, except that somewhere in there is one missing number.

How do we locate that one?

My immediate idea was something like:

    seatIDs = generateSeatIDs(boardingPasses)
    while seatIDs:
        tmpID = seatIDs.pop(0)
        if tmpID + 1 == seatIDs[0]:
            continue
        return tmpID + 1

Perhaps that would have been cleaner...

Instead I went full brute-force:

    seatIDs = generateSeatIDs(boardingPasses)
    firstSeat = min(seatIDs)
    lastSeat = max(seatIDs)
    for seat in range(firstSeat, lastSeat+1):
        if seat not in seatIDs:
            return seat

So in retrospect, instead of the first thought, which, written out like this, is not only cleaner and shorter, but... calling min() and max() means iterating over that data set (seatIDs) twice, to find the lowest/highest number in the set...

Had this been Python2, that range-function (`range(firstSeat, lastSeat+1)`) would also have generated a list of all those integers, which would have chewed up memory as well. (In Python3 it instead returns a range-object which is a small efficient iterator which calculates the next number in the sequence as it goes along, so Doge approves: wow, such efficient, much optimize, very save, wow.

Why did I do it this way instead? It *"feels"* more *"complete"* in some way. The road not taken only checks whether or not tmpID + 1 is in the list, but ought really **also** check something along the lines of `seatIDs[1] - 1 == tmpID + 1`. Now, the problem made it clear that there would only be one missing number, **our** seatID, so we shouldn't need to verify from "both ends", but since the problem stated that *"the seats with IDs +1 and -1 from yours will be in your list"* so it would still be prudent to check that while tmpID+1 shouldn't exist, that tmpID+2 does exist.

On the other hand, this explanation is bullshit as well... since in the actual solution I am not checking that mySeatID (missing) +/- 1 is present. So I don't know why I did it that way. Which kindof sucks. Oh well, if I do figure it out I will have to update this retro.
